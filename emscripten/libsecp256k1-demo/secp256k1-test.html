<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Demonstration of libsecp256k1 compiled with Emscripten</title>
    <script type="text/javascript" src="secp256k1.js"></script>
    <script src="//crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha256.js"></script>
    <script type="text/javascript" src="wordarrayconv.js"></script>
    <style type="text/css">
        form.container>div         { display: table;      }
        form.container>div>p       { display: table-row;  }
        form.container>div>p>label { display: table-cell; padding-right: 0.5em; }
        form.container>div>p>input { display: table-cell; width: 40em; }
    </style>
  </head>
  <body>
    <form id="crypto" class="container" action="#">
        <div>
        <p>
            <label for="msg">Message:</label>
            <input type="text" id="msg" placeholder="Type in message to sign and verify" />
        </p>
        <p>
            <label for="sec">Secret:</label>
            <input type="text" id="sec" placeholder="Secret passphrase from which secret key is derived" />
        </p>
        </div>
        <span id="wait">Waiting for libsecp256k1 to load...</span>
        <input type="submit" id="go" value="Sign and Verify" style="display: none" />
    </form>
    <pre id="out"></pre>

    <script type="text/javascript">
    function go(e)
    {
        var msg_str = document.getElementById("msg").value;
        var sec_str = document.getElementById("sec").value;
        console.log('Go with msg="'+msg_str+'" and sec="'+sec_str+'"');

        var out = document.getElementById("out");
        out.innerText = "";
        function log(s) {
            console.log(s);
            var str;
            if (typeof s === 'object')
            {
                if (s.hasOwnProperty('message'))
                {
                    str = s['message'];
                }
                else
                {
                    str = JSON.stringify(s);
                }
            }
            else
            {
                str = s.toString();
            }
            out.innerText += '\n' + str;
        }

        if (msg_str == "" || sec_str == "")
        {
            log("Error: You must fill in both fields!");
            return;
        }

        var state = {};
        state.msg = CryptoJS.enc.u8array.stringify(CryptoJS.SHA256(msg_str)); 
        state.seckey = CryptoJS.enc.u8array.stringify(CryptoJS.SHA256(sec_str));
        Promise.resolve()
        .then(function(ret) {
            log("Generated seckey from string: " + sec_str);
            var args = {seckey: state.seckey};
            return secp256k1.api.point(args).then(function(ret) {
                        // Pass updates to args up to state (needed for all TypedArrays)
                        state.seckey = args.seckey;
                        return ret;
            });
        }).then(function(ret) {
            state.pubkey = ret;
            log("Public key is: " + CryptoJS.enc.u8array.parse(state.pubkey).toString());
            var args = {msg: state.msg, seckey: state.seckey};
            return secp256k1.api.ecdsa_sign(args).then(function(ret) {
                        state.msg = args.msg;
                        state.seckey = args.seckey;
                        return ret;
            });
        }).then(function(ret) {
            state.sig = ret.sig;
            state.recid = ret.recid;
            log("Signature is: " + CryptoJS.enc.u8array.parse(state.sig).toString());
            log("recid = " + state.recid);
            var args = {msg: state.msg, sig: state.sig, recid: state.recid};
            return secp256k1.api.ecdsa_recover(args).then(function(ret) {
                        state.msg = args.msg;
                        state.sig = args.sig;
                        // No need to do this for state.recid since it is a Number, not a TypedArray, and so it won't be neutered.
                        return ret;
            });
        }).then(function(ret) {
            state.recovered_pubkey = ret;
            log("Recovered public key is: " + CryptoJS.enc.u8array.parse(state.recovered_pubkey).toString());
            for (var i = 0; i < state.pubkey.length; ++i)
            {
                if (state.recovered_pubkey[i] !== state.pubkey[i])
                {
                    log("Signature is incorrect.");
                    return;
                }
            }
            log("Signature is correct.");
        }).catch(function(error) {
            log("Error occured: ");
            log(error);
        });
    }
   
    document.getElementById("crypto").addEventListener("submit", function(e) { e.preventDefault(); }); 
    secp256k1.init().then(function() {
        document.getElementById("wait").style.display = "none";
        document.getElementById("go").style.display = "block";
        document.getElementById("crypto").addEventListener("submit", go);
        console.log('Loaded');
    });
    </script>
</body>
</html>
